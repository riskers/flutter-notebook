{"./":{"url":"./","title":"关于","keywords":"","body":"本书发布在 https://riskers.gitbooks.io/flutter-notebook ，感谢 github pages / gitbook / travis 提供的便利。 Flutter 是 Google 出品的一款跨终端开发的框架，为什么要选择它？ 热加载(hot reload)是 dev 支持的 ：UI 开发提速（不用 build）https://www.infoq.cn/article/why-flutter-uses-dart 注意不是热修复或热更新，目前 Flutter 不支持: https://github.com/flutter/flutter/issues/14330 理论上比 RN 等基于 JavaScript 的方案快 Google 下一代操作系统支持 针对前端来说，布局 Widget 类比 CSS，StatefulWidget 和 StatelessWidget 类比 React 组件，pub 类比 npm。 对于 Native 开发者，主要工作应是:开发 plugin、打包、协同等等。 整体来说，UI 部分为前端来做，应用的是自己熟悉的思想，不过是换了框架和语言。而 App 的底层功能调用为 Native 开发 plugin 来让前端来用。 目录 详见 SUMMARY 其中，前两章是对前端写的，后面则是对原生开发写的。 为什么要写这本书 自己也是刚上手，觉得很多概念很熟悉，入门成本不算高，就开始自己写这本书，也算是对 flutter 一个总结。 本书适合这样的前端 熟练 CSS，尤其是各种布局方式，比如 position、flex 有 TypeScript 或其他静态语言基础 操练过 React / Vue 这一类框架 想玩玩 Native 开发却不知如何开始，可以从 flutter 开始 本书没有这些内容 dart 教程，默认你已经看过至少一遍 dart 文档 Native 开发的介绍 能够学到 flutter 组件类型和常用组件介绍 flutter 数据管理、主题管理、依赖管理等 如何与 Native 开发混合开发 期待你的合作 native 部分内容 Native 开发工程师会比我更清楚，需要他们来研究、充实这一部分内容。 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"widgets/":{"url":"widgets/","title":"概述","keywords":"","body":" Widget 相关 stateless stateful bridge 常用 Widget Text ListView Image Container 布局 Widget Container Row / Column Stack 交互 Widget GestureDetector 项目架构 | - android # android Native code | - build # build temp code | - ios # ios Native code | - lib # flutter code | - test # 测试 可以看出，我们大部分工作是在写 lib 下的 flutter 代码: // lib/main.dart import 'package:flutter/material.dart'; void main() => runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter', home: Scaffold( appBar: new AppBar(title: new Text('Title')), body: new Text('Home') ) ); } } 一切皆 Widget flutter 里所有的东西都是 Widget，连文字、间距这样的值也是 Widget: Padding( padding: EdgeInsets.all(8.0), child: Text('this is text'), ) By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"widgets/statelesswidget.html":{"url":"widgets/statelesswidget.html","title":"StatelessWidget","keywords":"","body":"WidgetStateless 函数 Widget 写过 React 的人都知道纯函数组件，flutter 类比过来可以是这样: Widget helloRect() { return Container( color: Colors.purple, width: 200, height: 200, margin: EdgeInsets.all(16), child: Center(child: Text('Hi')), ); } Code StatelessWidget 但是 Flutter 中最常用的是 StatelessWidget: class HelloRect extends StatelessWidget { final String text; HelloRect({this.text}); @override Widget build(BuildContext context) { return Container( color: Colors.purple, width: 200, height: 200, margin: EdgeInsets.all(16), child: Center(child: Text(text)), ); } } Code 从 dart 语法来看 Widget 参数 上面的语法对于 dart 不熟悉的人可能会看不懂，这其实是 dart 的语法糖，不用的话就是这样: // 不使用语法糖 class HelloRect extends StatelessWidget { final String text; // HelloRect({this.text}); // 在构造函数中可以直接将 this 替换 HelloRect({String text}) { // text 是 String 类型的可选参数 this.text = text; } @override Widget build(BuildContext context) { return Container( color: Colors.purple, width: 200, height: 200, margin: EdgeInsets.all(16), // child: Center(child: Text(text)), // dart 中 this 是可省略的 child: Center(child: Text(this.text)), ); } } 这一段看懂之后就运行下面的代码，再看效果 : Code By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"widgets/statefulwidget.html":{"url":"widgets/statefulwidget.html","title":"StatefulWidget","keywords":"","body":"StatefulWidget 保存状态的 widget 实现一个 stateful 的 widget，可以继承 StatefulWidget 并在 createState 方法中返回一个 State。 // StatefulWidget 基本结构 class HelloRect extends StatefulWidget { HelloRect({ this.text }); final String text; @override createState() => _HelloRectState(); // 用 createState 创建一个 state 对象 } State 对象存储了 WidgetState 信息并且可以在对象的声明周期中发生改变。 class _HelloRectState extends State { var color = Colors.purple; @override Widget build(BuildContext context) { return Container( child: Text(widget.text), color: color, ); } } Code By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"widgets/basewidget.html":{"url":"widgets/basewidget.html","title":"基本组件","keywords":"","body":"Text Image new Image.network( 'https://ws1.sinaimg.cn/large/8e495e65ly1fyx06fa2d9j208s07agm5.jpg', fit: BoxFit.cover, repeat: ImageRepeat.repeatX, ), Flutter CSS BoxFit.cover background-size: cover BoxFit.contain background-size: contain ImageRepeat.repeatX background-repeat: repeat-x ImageRepeat.repeatY background-repeat: repeat-y Row 不灵活布局: 灵活布局 Expanded: 平均分配，一行充满 第三个 button 是自由伸缩的，前两个是 Expanded 的。 Code Column Code Expanded Stack Code By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"widgets/commonwidget.html":{"url":"widgets/commonwidget.html","title":"常用组件","keywords":"","body":"ListView 静态 Code 动态 Code GridView Code TabBar BottomNavigationBar Code Drawer By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"widgets/route.html":{"url":"widgets/route.html","title":"路由","keywords":"","body":"路由 Code 路由是什么不用解释，几乎所有前端框架都有自己的路由体系，无非是基于 history 或 hashchange 实现的。 flutter 中的路由就很简单，是原生实现的: // push 进入路由 Navigator.push( context, MaterialPageRoute(builder: (_) => SecondScreen()) ); // pop 退出路由 Navigator.pop(context); 完整代码 另外，还有一种命名路由的方式: // init: return MaterialApp( initialRoute: '/', routes: { '/': (_) => FirstScreen(), '/about': (_) => SecondScreen(), }, ); // 进入 about 页面 Navigator.pushNamed(context, '/about'); 完整代码 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"advanced/theme.html":{"url":"advanced/theme.html","title":"主题","keywords":"","body":"主题 主题分为全局主题和局部主题: android 和 ios 平台的差异性 -> 判断平台使用 widget > > 切换主题 -> Theme # theme ```dart import 'package:flutter/material.dart'; import 'package:flutter/cupertino.dart'; Theme.of(context).platform == TargetPlatform.iOS ? CupertinoSwitch( value: true, onChanged: (bool toggled) {}, ) : Switch( value: true, onChanged: (bool toggled) {}, ) ``` --> By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"advanced/module.html":{"url":"advanced/module.html","title":"模块管理","keywords":"","body":"模块管理 flutter 中模块有以下类型: Application: 一个完整的应用 Plugin: 与 iOS 或者 Android 通信的接口 Package: flutter Widget 他们本质上都是 dart 语言包，可以发布在 pub 上，可以参见之前写过的 给前端看的 dart 包管理与发布。 上文讲了 dart 的发包，现在说下 dart 中模块的引用和使用(引用本地文件): import './some_widget/some_widget.dart'; 这是相对路径，但也是 dart 不推荐的方法，实际上，你可以这么引用(确保 pubspec.yaml 中 name 字段是 flutter_demo): import 'package:flutter_demo/some_widget/some_widget.dart'; By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"advanced/resources.html":{"url":"advanced/resources.html","title":"资源依赖","keywords":"","body":"TODO... By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"advanced/bridge.html":{"url":"advanced/bridge.html","title":"widget 通信","keywords":"","body":"widget 之间通信 父子通信 同级通信 其他通信 详见 使用 redux 管理 flutter 应用数据 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"advanced/redux.html":{"url":"advanced/redux.html","title":"flutter 中使用 redux 管理状态","keywords":"","body":"使用 redux 管理 flutter 应用数据 redux 是什么？简单来说，就是为了解决 UI 层状态管理的方案，如果不熟悉，请先看文档学习一下，今天的重点不是学习 redux，而是直接用 redux 管理 flutter 的状态。 和 react 的比较 首先，flutter 和 react 真的太像了，连状态管理都有 redux 方案: flutter react redux.dart redux flutter_redux react-redux redux_thunk redux-thunk 另外，甚至还有 redux-epics 能够搭配 rxdart 对标 redux-observable。对于 rxjs 熟悉的人应该也能够很快地开始 rxdart 了，再次证明知识是相似的，技能也是能够越学越快的。 为了不混淆大家，接下来我把 react 中的 redux 称为 react/redux, flutter 中的 redux 称为 flutter/redux。 正题 现在我们用 flutter 写一个简单的 redux 例子: 完整代码在 https://github.com/riskers/flutter_notebook_redux ，有过 redux 经验的应该能看明白。使用到了: redux flutter_redux redux_thunk 项目架构完全是之前按照我之前在 React 中的经验来做的 有几点需要注意: 初始化 Store 为了方便，可以在 state 中以一个静态方法初始化: static AppState initialState() { return AppState( count: 0, clickCount: 0, ); } 然后在入口文件中调用: final store = Store( reducers, middleware: [thunkMiddleware], initialState: AppState.initialState(), // 调用 ); reducer 复制对象的方法 在 react/redux 中我们习惯这样写 reducer: const reducer = (state={ loading: false, data: [], }, action) => { switch(action.type) { case CONST.FETCH_GITHUB_SEARCH_USER_LOADING: return { ...state, loading: true } case CONST.FETCH_GITHUB_SEARCH_USER_SUCCESS: return { loading: false, data: action.payload.items } default: return state } } 重点是 ...state 这样的解构写法，实际是浅复制了 state 对象，而在 dart 中没有这么方便的方法，比如 reducers.dart 中的 copyWith: AppState counterReducer(AppState state, dynamic action) { switch (action) { case INCREMENT: return state.copyWith(count: state.count + 1); case DECREMENT: return state.copyWith(count: state.count - 1); } return state; } copyWith 是我们自己写的扩展方法： AppState copyWith({count, clickCount}) { return AppState( count: count ?? this.count, clickCount: clickCount ?? this.clickCount, ); } ?? 是条件表达式，count: count ?? this.count 表示 copyWith 只要没传进来 count 就把 AppState 实例的 count 值赋给 count，然后再实例化一个 AppState 对象。 参见其他的复制对象的方案 actions 比较有特点的就是 redux_thunk 的异步 action 写法: ThunkAction asyncIncrement() { return (Store store) async { await Future.delayed(Duration(seconds: 3)); // 延迟 3 秒 store.dispatch(INCREMENT); }; } async / await 是不是很熟悉？ StoreProvider / StoreConnector StoreProvider 很简单，就是在根组件中挂载 store: @override Widget build(BuildContext context) { return StoreProvider( store: store, child: MaterialApp( theme: ThemeData.dark(), home: Home(), ), ); } 而 StoreConnector 就比较麻烦了，需要先定义一个 ViewModel: class AppStateViewModel { final AppState state; final void Function() onClick; AppStateViewModel({ this.state, this.onClick, }); } ViewModel 中规定你要在这个组件中使用的 Store 中的数据 class AddButton extends StatelessWidget { @override Widget build(BuildContext context) { return StoreConnector( converter: (store) { return AppStateViewModel(onClick: () { store.dispatch(INCREMENT); store.dispatch(CLICK); }); }, builder: (context, vm) { return Padding( padding: const EdgeInsets.all(8.0), child: FloatingActionButton( onPressed: vm.onClick, // trigger! tooltip: 'Increment', child: Icon(Icons.exposure_plus_1), ), ); }, ); } } StoreConnector 有两个方法: converter: 使用给定的转换器函数将存储转换为 ViewModel，并将 ViewModel 传递给 builder 函数 builder: 承接 converter 返回的数据来使用 以 AddButton 组件为例，converter 返回 onClick 函数来触发 dispatch,builder 承接到这个函数，这样就能在发起 dispatch，走 redux 的流程了。 本文只介绍 redux 在 flutter 中的应用，如果你对 React 很熟，你应该能明白 redux 的意义，除了有个全局 store 外，深层组件之间通信也不是问题了，对于 flutter 这种框架也是很有意义的。 当然，直接使用 redux 可能会比较重，这和 react 是类似的，小应用的话可以用全局总线来处理，甚至你可以一个界面就是一个 statefulwidget，直接都用 setState 来改变数据渲染界面，这样每个界面都是独立的数据了。 总体上来说，在 flutter 上使用 redux 还是很麻烦的，好在官方在 2019 roadmap 中提到了要提供最佳实践，让我们期待吧！ By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"native/":{"url":"native/","title":"概述","keywords":"","body":"到了这里，其实就是 Native 开发工程师的工作了: 通信与 plugin: 当官方提供的 plugin 不能满足你的需求时，需要自己开发 plugin，而 plugin 的基础是 flutter 与 Native 的通信模型 在老项目中集成: 没有新项目，而是要在已有项目中尝试 flutter 打包: 与 Native 方法相同 整体来说，这些东西 Native 开发工程师会比我们更清楚，需要他们来研究这一部分内容。因为我没有 Native 开发的经验，所以只能很不负责任地把搜集到的资料列出来，期待有 Native 工程师来一起完善他。 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"native/plugins.html":{"url":"native/plugins.html","title":"通信 与 plugin","keywords":"","body":"通信 与 plugin 通信是 plugin 的基础，是指 flutter UI 界面与 Native 的数据交互，而 plugin 是在这种方式稳定之后的抽象。 通信 这篇文章的几种架构模型关注一下: https://mp.weixin.qq.com/s/32e-V9K2-VX97PAYVitUPQ Native jsbridge RN Flutter plugin 封装 API 插件 Flutter Plugin 调用 Native API By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"native/add_flutter_to_app.html":{"url":"native/add_flutter_to_app.html","title":"在现有 Android / iOS 项目中集成","keywords":"","body":" 官方 wiki: https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps Roadmap 2019 说到今年会更好地提供这方面支持。 原生 App 项目集成 flutter 混合开发详细指南(简单实用版) 集成到 iOS 和 Android 中 从零搭建 iOS Native Flutter 混合工程 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"native/build.html":{"url":"native/build.html","title":"打包","keywords":"","body":" Flutter 完整开发实战详解(三、 打包与填坑篇) By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"team/lint.html":{"url":"team/lint.html","title":"Lint 工具","keywords":"","body":"Lint 工具 团队协作的第一步就是团队统一代码风格，前端有 ESLint 和 TSLint，dart 也就有 dart Lint。 在根目录新建 analysis_options.yaml 文件，然后团队 leader 在熟悉 dart 之后可以根据需要配置 rules 就行了。 在 IDE 中的效果: dart lint 的全`部 rules 可见 http://dart-lang.github.io/linter/lints/。 如果你嫌一个个看麻烦，可以直接把 flutter 的 dart lint 抄过来: https://github.com/flutter/flutter/blob/master/analysis_options.yaml 最后，dart plugin 还提供了可视化的 analysis，点击查看: By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"team/product.html":{"url":"team/product.html","title":"工程管理","keywords":"","body":"TODO... By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"ending/resources.html":{"url":"ending/resources.html","title":"资源","keywords":"","body":"资源集合 repo flutter-go: 阿里巴巴维护的 flutter widgets 展示项目 HistoryOfEverything: Flutter 2019 上展示的 History 项目 gitme: github 客户端 Flutter-Notebook: 日更的 FlutterDemo 合集 Article 咸鱼系列文章 为什么说 Flutter 不一定是趋势? 为什么我觉得 Flutter 短期内不会流行但依然选择学习它 《Flutter 实战》 我看完掘金上的 227 篇文章，总结出一份 Flutter 入门教程 Video Flutter Live 2018 Flutter Widget of the Week Dart (Flutter Tutorials) 我的 Example flutter_notebook_redux flutter_data_flow By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "},"ending/":{"url":"ending/","title":"总结","keywords":"","body":"总结 从我入门的历程来看: dart 语法不用纠结，就像刚开始学习 React 一样，慢慢就熟悉了 构建 UI 部分也不用纠结，我们刚开始学 HTML / CSS 不也一样么，看着属性很多，其实常用的就那 20 个左右 flutter 或者 React-Native 这种跨端开发真正能在生产环境用，我觉得需要团队中有分别对 flutter 、iOS 和 Android 很熟悉的人，尤其是对 Native 开发很熟的人，因为 flutter 构建 UI 层是没有什么难度，难的是: 怎么在现有项目中集成进来，需要 Native 开发者思考 怎么在现有的团队中开始协作三端人员，需要项目管理者思考 目前社区没有给方案，大厂都在说概念，没有说工程，需要自己团队摸索。 flutter vs web: 思路一样，都是基于界面编程，没有什么高大上的概念。 说着是写写 flutter 的笔记，不过好像复习了一遍 react。 By riskers，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2019-10-25 13:40:12 "}}